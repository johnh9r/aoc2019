defmodule IntCodeDoublePlus do
  @moduledoc """
  execute CISC instructions on integer data

  * support callback function to obtain next input value (consumed by opcode 3)
  * support callback function to emit next output value (generated by opcode 4)
  """

  # addressing modes for opcode parameters
  @pos_mode 0
  @imm_mode 1

  @doc """
  iex> IntCodeDoublePlus.execute([1, 9, 10, 3, 2, 3, 11, 0, 99, 30, 40, 50])
  [3500, 9, 10, 70, 2, 3, 11, 0, 99, 30, 40, 50]

  iex> IntCodeDoublePlus.execute([1, 0, 0, 0, 99])
  [2, 0, 0, 0, 99]

  iex> IntCodeDoublePlus.execute([2, 3, 0, 3, 99])
  [2, 3, 0, 6, 99]

  iex> IntCodeDoublePlus.execute([2, 4, 4, 5, 99, 0])
  [2, 4, 4, 5, 99, 9801]

  iex> IntCodeDoublePlus.execute([1, 1, 1, 4, 99, 5, 6, 0, 99])
  [30, 1, 1, 4, 2, 5, 6, 0, 99]
  """
  @spec execute([integer], (-> integer), (integer -> integer)) :: [integer]
  def execute(
    xs,
    input_fun \\ fn -> raise "(EOF@stdin)" end,
    output_fun \\ fn _ -> end
  )
  def execute([], _, _), do: []
  def execute(xs, input_fun, output_fun), do: _execute(xs, 0, input_fun, output_fun)

  @spec _execute([integer], integer, (-> integer), (integer -> integer)) :: [integer]
  defp _execute(xs, i, input_fun, output_fun) do
    [op_param_modes] = cisc_at(xs, i, 1)

    op = op_param_modes |> Kernel.rem(100)
    param_mode1 = op_param_modes |> Kernel.div(  100) |> Kernel.rem(10)
    param_mode2 = op_param_modes |> Kernel.div( 1000) |> Kernel.rem(10)
    # "Parameters that an instruction writes to will never be in immediate mode."
    0 = op_param_modes |> Kernel.div(10000) |> Kernel.rem(10)

    case op do
      # halt (returning core dump for possible debugging)
      99 ->
        xs

      # add
      1 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value = load_param1.(xs, ld1off) + load_param2.(xs, ld2off)
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input_fun, output_fun)

      # mult
      2 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value = load_param1.(xs, ld1off) * load_param2.(xs, ld2off)
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input_fun, output_fun)

      # store input from environment
      3 ->
        insn_sz = 2
        # "Parameters that an instruction writes to will never be in immediate mode."
        [_, st_off] = cisc_at(xs, i, insn_sz)

        value = input_fun.()
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input_fun, output_fun)

      # generate output to environment
      4 ->
        insn_sz = 2
        [_, ld_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        output_value =
          load_param1.(xs, ld_off)

        output_fun.(output_value)
        _execute(xs, i + insn_sz, input_fun, output_fun)

      # jmpnz
      5 ->
        insn_sz = 3
        [_, ld_off, target] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        if load_param1.(xs, ld_off) != 0 do
          _execute(xs, load_param2.(xs, target), input_fun, output_fun)
        else
          _execute(xs, i + insn_sz, input_fun, output_fun)
        end

      # jmpz
      6 ->
        insn_sz = 3
        [_, ld_off, target] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        if load_param1.(xs, ld_off) == 0 do
          _execute(xs, load_param2.(xs, target), input_fun, output_fun)
        else
          _execute(xs, i + insn_sz, input_fun, output_fun)
        end

      # stlt
      7 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value =
          if load_param1.(xs, ld1off) < load_param2.(xs, ld2off),
            do: 1,
            else: 0

        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input_fun, output_fun)

      # steq
      8 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value =
          if load_param1.(xs, ld1off) == load_param2.(xs, ld2off),
            do: 1,
            else: 0

        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input_fun, output_fun)

      x ->
        raise "unknown opcode: #{Integer.to_string(x)}"
    end
  end

  defp loader_for(param_mode) do
    case param_mode do
      @pos_mode ->
        &load_at!/2

      @imm_mode ->
        fn _, x -> x end
    end
  end

  defp load_at!(xs, offset) do
    Enum.fetch!(xs, offset)
  end

  defp store_at(xs, offset, value) do
    List.replace_at(xs, offset, value)
  end

  # first instruction resides at position zero;
  # return empty list on out-of-bounds access attempt
  @spec cisc_at([integer], integer, integer) :: [integer]
  defp cisc_at(xs, i, n) do
    xs
    |> Enum.drop(i)
    |> Enum.take(n)
  end
end
