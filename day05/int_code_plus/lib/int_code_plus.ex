defmodule IntCodePlus do
  @moduledoc """
  execute CISC instructions on integer data

  ### new observations:
  * support single initial input value to be consumed by opcode 3
  * support single output value to be generated by opcode 4
  * input stream may now contain negative values
  * added addressing modes encoded in opcode
 
  ### observations:
  * instruction 99 violates 4-octet instruction format
  * random-access addressing
    - earlier data positions can be accessed by opcodes appearing later
    - earlier opcodes can reference data beyond their own position
  * linear execution
    - no jump instruction, so iterate at granularity of instruction format
  * input stream cannot contain holes (for lack of notation), inviting list representation
  * input stream can self-modify by writing to later opcode positions

  ### assumptions:
  * data references will not reach beyond boundaries of input stream
  * instruction stream will terminate properly, not end abruptly

  ### constraints:
  * type `Integer` in Elixir is arbitrary-precision so cannot overflow
  """

  # XXX self-testing input?!
  #
  @doc """
  iex> IntCodePlus.execute([1, 9, 10, 3, 2, 3, 11, 0, 99, 30, 40, 50])
  [3500, 9, 10, 70, 2, 3, 11, 0, 99, 30, 40, 50]

  iex> IntCodePlus.execute([1, 0, 0, 0, 99])
  [2, 0, 0, 0, 99]

  iex> IntCodePlus.execute([2, 3, 0, 3, 99])
  [2, 3, 0, 6, 99]

  iex> IntCodePlus.execute([2, 4, 4, 5, 99, 0])
  [2, 4, 4, 5, 99, 9801]

  iex> IntCodePlus.execute([1, 1, 1, 4, 99, 5, 6, 0, 99])
  [30, 1, 1, 4, 2, 5, 6, 0, 99]
  """
  # TODO return tuple to express single-value output: {integer, [integer]}
  @spec execute([integer], integer) :: [integer]
  def execute(xs, input \\ 1)

  @spec execute([integer], integer) :: [integer]
  def execute([], _), do: []

  def execute(xs, input) do
    _execute(xs, 0, input)
  end

  @spec _execute([integer], integer, integer) :: [integer]
  defp _execute(xs, i, input) do
    [op_param_modes] = cisc_at(xs, i, 1)

    op = op_param_modes |> Kernel.rem(100)
    _param_mode1 = op_param_modes |> Kernel.div(  100) |> Kernel.rem(10)
    _param_mode2 = op_param_modes |> Kernel.div( 1000) |> Kernel.rem(10)
    _param_mode3 = op_param_modes |> Kernel.div(10000) |> Kernel.rem(10)

    case op do
      # halt
      99 ->
        # TODO return tuple to express single-value output: {integer, [integer]}
        xs

      # add
      1 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        value = load_at!(xs, ld1off) + load_at!(xs, ld2off)
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input)

      # mult
      2 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        value = load_at!(xs, ld1off) * load_at!(xs, ld2off)
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input)

      # store input from environment
      3 ->
        insn_sz = 2
        [_, st_off] = cisc_at(xs, i, insn_sz)

        store_at(xs, st_off, input)
        |> _execute(i + insn_sz, input)

      # generate output to environment
      4 ->
        insn_sz = 2
        [_, ld_off] = cisc_at(xs, i, insn_sz)

        # TODO
        _output = load_at!(xs, ld_off)

      _ ->
        []
    end
  end

  defp load_at!(xs, offset) do
    Enum.fetch!(xs, offset)
  end

  defp store_at(xs, offset, value) do
    List.replace_at(xs, offset, value)
  end

  # first instruction resides at position zero;
  # return empty list on out-of-bounds access attempt
  @spec cisc_at([integer], integer, integer) :: [integer]
  defp cisc_at(xs, i, n) do
    xs
    |> Enum.drop(i)
    |> Enum.take(n)
  end
end
