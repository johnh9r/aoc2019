defmodule IntCodePlus do
  @moduledoc """
  execute CISC instructions on integer data

  ### new observations:
  * support single initial input value to be consumed by opcode 3
  * support single output value to be generated by opcode 4
  * input stream may now contain negative values
  * added addressing modes encoded in opcode
 
  ### observations:
  * instruction 99 violates 4-octet instruction format
  * random-access addressing
    - earlier data positions can be accessed by opcodes appearing later
    - earlier opcodes can reference data beyond their own position
  * linear execution
    - no jump instruction, so iterate at granularity of instruction format
  * input stream cannot contain holes (for lack of notation), inviting list representation
  * input stream can self-modify by writing to later opcode positions

  ### assumptions:
  * data references will not reach beyond boundaries of input stream
  * instruction stream will terminate properly, not end abruptly

  ### constraints:
  * type `Integer` in Elixir is arbitrary-precision so cannot overflow
  """

  # addressing modes for opcode parameters
  @pos_mode 0
  @imm_mode 1

  @doc """
  iex> IntCodePlus.execute([1, 9, 10, 3, 2, 3, 11, 0, 99, 30, 40, 50])
  {0xcafebabe, [3500, 9, 10, 70, 2, 3, 11, 0, 99, 30, 40, 50]}

  iex> IntCodePlus.execute([1, 0, 0, 0, 99])
  {0xcafebabe, [2, 0, 0, 0, 99]}

  iex> IntCodePlus.execute([2, 3, 0, 3, 99])
  {0xcafebabe, [2, 3, 0, 6, 99]}

  iex> IntCodePlus.execute([2, 4, 4, 5, 99, 0])
  {0xcafebabe, [2, 4, 4, 5, 99, 9801]}

  iex> IntCodePlus.execute([1, 1, 1, 4, 99, 5, 6, 0, 99])
  {0xcafebabe, [30, 1, 1, 4, 2, 5, 6, 0, 99]}
  """
  @spec execute([integer], integer) :: {integer, [integer]}
  def execute(xs, input \\ 1)
  def execute([], _), do: []
  def execute(xs, input), do: _execute(xs, 0, input)

  @spec _execute([integer], integer, integer, integer) :: {integer, [integer]}
  defp _execute(xs, i, input, output \\ 0xcafebabe) do
    [op_param_modes] = cisc_at(xs, i, 1)

    op = op_param_modes |> Kernel.rem(100)
    param_mode1 = op_param_modes |> Kernel.div(  100) |> Kernel.rem(10)
    param_mode2 = op_param_modes |> Kernel.div( 1000) |> Kernel.rem(10)
    # "Parameters that an instruction writes to will never be in immediate mode."
    0 = op_param_modes |> Kernel.div(10000) |> Kernel.rem(10)

    case op do
      # halt
      99 ->
        {output, xs}

      # add
      1 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value = load_param1.(xs, ld1off) + load_param2.(xs, ld2off)
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input, output)

      # mult
      2 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value = load_param1.(xs, ld1off) * load_param2.(xs, ld2off)
        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input, output)

      # store input from environment
      3 ->
        insn_sz = 2
        # "Parameters that an instruction writes to will never be in immediate mode."
        [_, st_off] = cisc_at(xs, i, insn_sz)

        store_at(xs, st_off, input)
        |> _execute(i + insn_sz, input, output)

      # generate output to environment
      4 ->
        insn_sz = 2
        [_, ld_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        output_value =
          load_param1.(xs, ld_off)
          |> IO.inspect(label: "output")
        _execute(xs, i + insn_sz, input, output_value)

      # jmpnz
      5 ->
        insn_sz = 3
        [_, ld_off, target] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        if load_param1.(xs, ld_off) != 0 do
          _execute(xs, load_param2.(xs, target), input, output)
        else
          _execute(xs, i + insn_sz, input, output)
        end

      # jmpz
      6 ->
        insn_sz = 3
        [_, ld_off, target] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        if load_param1.(xs, ld_off) == 0 do
          _execute(xs, load_param2.(xs, target), input, output)
        else
          _execute(xs, i + insn_sz, input, output)
        end

      # stlt
      7 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value =
          if load_param1.(xs, ld1off) < load_param2.(xs, ld2off),
            do: 1,
            else: 0

        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input, output)

      # steq
      8 ->
        insn_sz = 4
        [_, ld1off, ld2off, st_off] = cisc_at(xs, i, insn_sz)

        load_param1 = loader_for(param_mode1)
        load_param2 = loader_for(param_mode2)
        value =
          if load_param1.(xs, ld1off) == load_param2.(xs, ld2off),
            do: 1,
            else: 0

        store_at(xs, st_off, value)
        |> _execute(i + insn_sz, input, output)

      x ->
        Integer.to_string(x) |> IO.inspect(label: "unknown opcode")
        []
    end
  end

  defp loader_for(param_mode) do
    case param_mode do
      @pos_mode ->
        &load_at!/2

      @imm_mode ->
        fn _, x -> x end
    end
  end

  defp load_at!(xs, offset) do
    Enum.fetch!(xs, offset)
  end

  defp store_at(xs, offset, value) do
    List.replace_at(xs, offset, value)
  end

  # first instruction resides at position zero;
  # return empty list on out-of-bounds access attempt
  @spec cisc_at([integer], integer, integer) :: [integer]
  defp cisc_at(xs, i, n) do
    xs
    |> Enum.drop(i)
    |> Enum.take(n)
  end
end
